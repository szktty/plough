// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'graph_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$GraphNodeData {
  GraphId get id => throw _privateConstructorUsedError;
  Offset get logicalPosition => throw _privateConstructorUsedError;
  double get weight => throw _privateConstructorUsedError;
  int get stackOrder => throw _privateConstructorUsedError;
  bool get isEnabled => throw _privateConstructorUsedError;
  bool get visible => throw _privateConstructorUsedError;
  bool get canSelect => throw _privateConstructorUsedError;
  bool get canDrag => throw _privateConstructorUsedError;
  bool get isArranged => throw _privateConstructorUsedError;

  /// Create a copy of GraphNodeData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GraphNodeDataCopyWith<GraphNodeData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GraphNodeDataCopyWith<$Res> {
  factory $GraphNodeDataCopyWith(
          GraphNodeData value, $Res Function(GraphNodeData) then) =
      _$GraphNodeDataCopyWithImpl<$Res, GraphNodeData>;
  @useResult
  $Res call(
      {GraphId id,
      Offset logicalPosition,
      double weight,
      int stackOrder,
      bool isEnabled,
      bool visible,
      bool canSelect,
      bool canDrag,
      bool isArranged});

  $GraphIdCopyWith<$Res> get id;
}

/// @nodoc
class _$GraphNodeDataCopyWithImpl<$Res, $Val extends GraphNodeData>
    implements $GraphNodeDataCopyWith<$Res> {
  _$GraphNodeDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GraphNodeData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? logicalPosition = null,
    Object? weight = null,
    Object? stackOrder = null,
    Object? isEnabled = null,
    Object? visible = null,
    Object? canSelect = null,
    Object? canDrag = null,
    Object? isArranged = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as GraphId,
      logicalPosition: null == logicalPosition
          ? _value.logicalPosition
          : logicalPosition // ignore: cast_nullable_to_non_nullable
              as Offset,
      weight: null == weight
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double,
      stackOrder: null == stackOrder
          ? _value.stackOrder
          : stackOrder // ignore: cast_nullable_to_non_nullable
              as int,
      isEnabled: null == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      visible: null == visible
          ? _value.visible
          : visible // ignore: cast_nullable_to_non_nullable
              as bool,
      canSelect: null == canSelect
          ? _value.canSelect
          : canSelect // ignore: cast_nullable_to_non_nullable
              as bool,
      canDrag: null == canDrag
          ? _value.canDrag
          : canDrag // ignore: cast_nullable_to_non_nullable
              as bool,
      isArranged: null == isArranged
          ? _value.isArranged
          : isArranged // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  /// Create a copy of GraphNodeData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GraphIdCopyWith<$Res> get id {
    return $GraphIdCopyWith<$Res>(_value.id, (value) {
      return _then(_value.copyWith(id: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$GraphNodeDataImplCopyWith<$Res>
    implements $GraphNodeDataCopyWith<$Res> {
  factory _$$GraphNodeDataImplCopyWith(
          _$GraphNodeDataImpl value, $Res Function(_$GraphNodeDataImpl) then) =
      __$$GraphNodeDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {GraphId id,
      Offset logicalPosition,
      double weight,
      int stackOrder,
      bool isEnabled,
      bool visible,
      bool canSelect,
      bool canDrag,
      bool isArranged});

  @override
  $GraphIdCopyWith<$Res> get id;
}

/// @nodoc
class __$$GraphNodeDataImplCopyWithImpl<$Res>
    extends _$GraphNodeDataCopyWithImpl<$Res, _$GraphNodeDataImpl>
    implements _$$GraphNodeDataImplCopyWith<$Res> {
  __$$GraphNodeDataImplCopyWithImpl(
      _$GraphNodeDataImpl _value, $Res Function(_$GraphNodeDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of GraphNodeData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? logicalPosition = null,
    Object? weight = null,
    Object? stackOrder = null,
    Object? isEnabled = null,
    Object? visible = null,
    Object? canSelect = null,
    Object? canDrag = null,
    Object? isArranged = null,
  }) {
    return _then(_$GraphNodeDataImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as GraphId,
      logicalPosition: null == logicalPosition
          ? _value.logicalPosition
          : logicalPosition // ignore: cast_nullable_to_non_nullable
              as Offset,
      weight: null == weight
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double,
      stackOrder: null == stackOrder
          ? _value.stackOrder
          : stackOrder // ignore: cast_nullable_to_non_nullable
              as int,
      isEnabled: null == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      visible: null == visible
          ? _value.visible
          : visible // ignore: cast_nullable_to_non_nullable
              as bool,
      canSelect: null == canSelect
          ? _value.canSelect
          : canSelect // ignore: cast_nullable_to_non_nullable
              as bool,
      canDrag: null == canDrag
          ? _value.canDrag
          : canDrag // ignore: cast_nullable_to_non_nullable
              as bool,
      isArranged: null == isArranged
          ? _value.isArranged
          : isArranged // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$GraphNodeDataImpl implements _GraphNodeData {
  const _$GraphNodeDataImpl(
      {required this.id,
      this.logicalPosition = Offset.zero,
      this.weight = 1.0,
      this.stackOrder = -1,
      this.isEnabled = true,
      this.visible = true,
      this.canSelect = true,
      this.canDrag = true,
      this.isArranged = false});

  @override
  final GraphId id;
  @override
  @JsonKey()
  final Offset logicalPosition;
  @override
  @JsonKey()
  final double weight;
  @override
  @JsonKey()
  final int stackOrder;
  @override
  @JsonKey()
  final bool isEnabled;
  @override
  @JsonKey()
  final bool visible;
  @override
  @JsonKey()
  final bool canSelect;
  @override
  @JsonKey()
  final bool canDrag;
  @override
  @JsonKey()
  final bool isArranged;

  @override
  String toString() {
    return 'GraphNodeData(id: $id, logicalPosition: $logicalPosition, weight: $weight, stackOrder: $stackOrder, isEnabled: $isEnabled, visible: $visible, canSelect: $canSelect, canDrag: $canDrag, isArranged: $isArranged)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GraphNodeDataImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.logicalPosition, logicalPosition) ||
                other.logicalPosition == logicalPosition) &&
            (identical(other.weight, weight) || other.weight == weight) &&
            (identical(other.stackOrder, stackOrder) ||
                other.stackOrder == stackOrder) &&
            (identical(other.isEnabled, isEnabled) ||
                other.isEnabled == isEnabled) &&
            (identical(other.visible, visible) || other.visible == visible) &&
            (identical(other.canSelect, canSelect) ||
                other.canSelect == canSelect) &&
            (identical(other.canDrag, canDrag) || other.canDrag == canDrag) &&
            (identical(other.isArranged, isArranged) ||
                other.isArranged == isArranged));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, logicalPosition, weight,
      stackOrder, isEnabled, visible, canSelect, canDrag, isArranged);

  /// Create a copy of GraphNodeData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GraphNodeDataImplCopyWith<_$GraphNodeDataImpl> get copyWith =>
      __$$GraphNodeDataImplCopyWithImpl<_$GraphNodeDataImpl>(this, _$identity);
}

abstract class _GraphNodeData implements GraphNodeData {
  const factory _GraphNodeData(
      {required final GraphId id,
      final Offset logicalPosition,
      final double weight,
      final int stackOrder,
      final bool isEnabled,
      final bool visible,
      final bool canSelect,
      final bool canDrag,
      final bool isArranged}) = _$GraphNodeDataImpl;

  @override
  GraphId get id;
  @override
  Offset get logicalPosition;
  @override
  double get weight;
  @override
  int get stackOrder;
  @override
  bool get isEnabled;
  @override
  bool get visible;
  @override
  bool get canSelect;
  @override
  bool get canDrag;
  @override
  bool get isArranged;

  /// Create a copy of GraphNodeData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GraphNodeDataImplCopyWith<_$GraphNodeDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GraphLinkData {
  GraphId get id => throw _privateConstructorUsedError;
  GraphNode? get source => throw _privateConstructorUsedError;
  GraphNode? get target => throw _privateConstructorUsedError;
  GraphLinkDirection get direction => throw _privateConstructorUsedError;
  Offset get logicalPosition => throw _privateConstructorUsedError;
  double get weight => throw _privateConstructorUsedError;
  int get stackOrder => throw _privateConstructorUsedError;
  bool get isEnabled => throw _privateConstructorUsedError;
  bool get visible => throw _privateConstructorUsedError;
  bool get canSelect => throw _privateConstructorUsedError;
  bool get canDrag => throw _privateConstructorUsedError;
  bool get isArranged => throw _privateConstructorUsedError;

  /// Create a copy of GraphLinkData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GraphLinkDataCopyWith<GraphLinkData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GraphLinkDataCopyWith<$Res> {
  factory $GraphLinkDataCopyWith(
          GraphLinkData value, $Res Function(GraphLinkData) then) =
      _$GraphLinkDataCopyWithImpl<$Res, GraphLinkData>;
  @useResult
  $Res call(
      {GraphId id,
      GraphNode? source,
      GraphNode? target,
      GraphLinkDirection direction,
      Offset logicalPosition,
      double weight,
      int stackOrder,
      bool isEnabled,
      bool visible,
      bool canSelect,
      bool canDrag,
      bool isArranged});

  $GraphIdCopyWith<$Res> get id;
}

/// @nodoc
class _$GraphLinkDataCopyWithImpl<$Res, $Val extends GraphLinkData>
    implements $GraphLinkDataCopyWith<$Res> {
  _$GraphLinkDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GraphLinkData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? source = freezed,
    Object? target = freezed,
    Object? direction = null,
    Object? logicalPosition = null,
    Object? weight = null,
    Object? stackOrder = null,
    Object? isEnabled = null,
    Object? visible = null,
    Object? canSelect = null,
    Object? canDrag = null,
    Object? isArranged = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as GraphId,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as GraphNode?,
      target: freezed == target
          ? _value.target
          : target // ignore: cast_nullable_to_non_nullable
              as GraphNode?,
      direction: null == direction
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as GraphLinkDirection,
      logicalPosition: null == logicalPosition
          ? _value.logicalPosition
          : logicalPosition // ignore: cast_nullable_to_non_nullable
              as Offset,
      weight: null == weight
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double,
      stackOrder: null == stackOrder
          ? _value.stackOrder
          : stackOrder // ignore: cast_nullable_to_non_nullable
              as int,
      isEnabled: null == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      visible: null == visible
          ? _value.visible
          : visible // ignore: cast_nullable_to_non_nullable
              as bool,
      canSelect: null == canSelect
          ? _value.canSelect
          : canSelect // ignore: cast_nullable_to_non_nullable
              as bool,
      canDrag: null == canDrag
          ? _value.canDrag
          : canDrag // ignore: cast_nullable_to_non_nullable
              as bool,
      isArranged: null == isArranged
          ? _value.isArranged
          : isArranged // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  /// Create a copy of GraphLinkData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GraphIdCopyWith<$Res> get id {
    return $GraphIdCopyWith<$Res>(_value.id, (value) {
      return _then(_value.copyWith(id: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$GraphLinkDataImplCopyWith<$Res>
    implements $GraphLinkDataCopyWith<$Res> {
  factory _$$GraphLinkDataImplCopyWith(
          _$GraphLinkDataImpl value, $Res Function(_$GraphLinkDataImpl) then) =
      __$$GraphLinkDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {GraphId id,
      GraphNode? source,
      GraphNode? target,
      GraphLinkDirection direction,
      Offset logicalPosition,
      double weight,
      int stackOrder,
      bool isEnabled,
      bool visible,
      bool canSelect,
      bool canDrag,
      bool isArranged});

  @override
  $GraphIdCopyWith<$Res> get id;
}

/// @nodoc
class __$$GraphLinkDataImplCopyWithImpl<$Res>
    extends _$GraphLinkDataCopyWithImpl<$Res, _$GraphLinkDataImpl>
    implements _$$GraphLinkDataImplCopyWith<$Res> {
  __$$GraphLinkDataImplCopyWithImpl(
      _$GraphLinkDataImpl _value, $Res Function(_$GraphLinkDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of GraphLinkData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? source = freezed,
    Object? target = freezed,
    Object? direction = null,
    Object? logicalPosition = null,
    Object? weight = null,
    Object? stackOrder = null,
    Object? isEnabled = null,
    Object? visible = null,
    Object? canSelect = null,
    Object? canDrag = null,
    Object? isArranged = null,
  }) {
    return _then(_$GraphLinkDataImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as GraphId,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as GraphNode?,
      target: freezed == target
          ? _value.target
          : target // ignore: cast_nullable_to_non_nullable
              as GraphNode?,
      direction: null == direction
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as GraphLinkDirection,
      logicalPosition: null == logicalPosition
          ? _value.logicalPosition
          : logicalPosition // ignore: cast_nullable_to_non_nullable
              as Offset,
      weight: null == weight
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double,
      stackOrder: null == stackOrder
          ? _value.stackOrder
          : stackOrder // ignore: cast_nullable_to_non_nullable
              as int,
      isEnabled: null == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      visible: null == visible
          ? _value.visible
          : visible // ignore: cast_nullable_to_non_nullable
              as bool,
      canSelect: null == canSelect
          ? _value.canSelect
          : canSelect // ignore: cast_nullable_to_non_nullable
              as bool,
      canDrag: null == canDrag
          ? _value.canDrag
          : canDrag // ignore: cast_nullable_to_non_nullable
              as bool,
      isArranged: null == isArranged
          ? _value.isArranged
          : isArranged // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$GraphLinkDataImpl implements _GraphLinkData {
  const _$GraphLinkDataImpl(
      {required this.id,
      this.source,
      this.target,
      this.direction = GraphLinkDirection.none,
      this.logicalPosition = Offset.zero,
      this.weight = 1.0,
      this.stackOrder = -1,
      this.isEnabled = true,
      this.visible = true,
      this.canSelect = true,
      this.canDrag = true,
      this.isArranged = false});

  @override
  final GraphId id;
  @override
  final GraphNode? source;
  @override
  final GraphNode? target;
  @override
  @JsonKey()
  final GraphLinkDirection direction;
  @override
  @JsonKey()
  final Offset logicalPosition;
  @override
  @JsonKey()
  final double weight;
  @override
  @JsonKey()
  final int stackOrder;
  @override
  @JsonKey()
  final bool isEnabled;
  @override
  @JsonKey()
  final bool visible;
  @override
  @JsonKey()
  final bool canSelect;
  @override
  @JsonKey()
  final bool canDrag;
  @override
  @JsonKey()
  final bool isArranged;

  @override
  String toString() {
    return 'GraphLinkData(id: $id, source: $source, target: $target, direction: $direction, logicalPosition: $logicalPosition, weight: $weight, stackOrder: $stackOrder, isEnabled: $isEnabled, visible: $visible, canSelect: $canSelect, canDrag: $canDrag, isArranged: $isArranged)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GraphLinkDataImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.target, target) || other.target == target) &&
            (identical(other.direction, direction) ||
                other.direction == direction) &&
            (identical(other.logicalPosition, logicalPosition) ||
                other.logicalPosition == logicalPosition) &&
            (identical(other.weight, weight) || other.weight == weight) &&
            (identical(other.stackOrder, stackOrder) ||
                other.stackOrder == stackOrder) &&
            (identical(other.isEnabled, isEnabled) ||
                other.isEnabled == isEnabled) &&
            (identical(other.visible, visible) || other.visible == visible) &&
            (identical(other.canSelect, canSelect) ||
                other.canSelect == canSelect) &&
            (identical(other.canDrag, canDrag) || other.canDrag == canDrag) &&
            (identical(other.isArranged, isArranged) ||
                other.isArranged == isArranged));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      source,
      target,
      direction,
      logicalPosition,
      weight,
      stackOrder,
      isEnabled,
      visible,
      canSelect,
      canDrag,
      isArranged);

  /// Create a copy of GraphLinkData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GraphLinkDataImplCopyWith<_$GraphLinkDataImpl> get copyWith =>
      __$$GraphLinkDataImplCopyWithImpl<_$GraphLinkDataImpl>(this, _$identity);
}

abstract class _GraphLinkData implements GraphLinkData {
  const factory _GraphLinkData(
      {required final GraphId id,
      final GraphNode? source,
      final GraphNode? target,
      final GraphLinkDirection direction,
      final Offset logicalPosition,
      final double weight,
      final int stackOrder,
      final bool isEnabled,
      final bool visible,
      final bool canSelect,
      final bool canDrag,
      final bool isArranged}) = _$GraphLinkDataImpl;

  @override
  GraphId get id;
  @override
  GraphNode? get source;
  @override
  GraphNode? get target;
  @override
  GraphLinkDirection get direction;
  @override
  Offset get logicalPosition;
  @override
  double get weight;
  @override
  int get stackOrder;
  @override
  bool get isEnabled;
  @override
  bool get visible;
  @override
  bool get canSelect;
  @override
  bool get canDrag;
  @override
  bool get isArranged;

  /// Create a copy of GraphLinkData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GraphLinkDataImplCopyWith<_$GraphLinkDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GraphData {
  /// Unique identifier for this graph instance.
  GraphId get id => throw _privateConstructorUsedError;

  /// Map of node IDs to their corresponding [GraphNode] instances.
  IMap<GraphId, GraphNode> get nodes => throw _privateConstructorUsedError;

  /// Map of link IDs to their corresponding [GraphLink] instances.
  IMap<GraphId, GraphLink> get links => throw _privateConstructorUsedError;

  /// List of IDs for currently selected nodes.
  IList<GraphId> get selectedNodeIds => throw _privateConstructorUsedError;

  /// List of IDs for currently selected links.
  IList<GraphId> get selectedLinkIds => throw _privateConstructorUsedError;

  /// Whether selection of graph elements is enabled.
  bool get allowSelection => throw _privateConstructorUsedError;

  /// Whether multiple elements can be selected simultaneously.
  bool get allowMultiSelection => throw _privateConstructorUsedError;
  bool get needsLayout => throw _privateConstructorUsedError;
  GraphViewGeometry? get geometry => throw _privateConstructorUsedError;

  /// Create a copy of GraphData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GraphDataCopyWith<GraphData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GraphDataCopyWith<$Res> {
  factory $GraphDataCopyWith(GraphData value, $Res Function(GraphData) then) =
      _$GraphDataCopyWithImpl<$Res, GraphData>;
  @useResult
  $Res call(
      {GraphId id,
      IMap<GraphId, GraphNode> nodes,
      IMap<GraphId, GraphLink> links,
      IList<GraphId> selectedNodeIds,
      IList<GraphId> selectedLinkIds,
      bool allowSelection,
      bool allowMultiSelection,
      bool needsLayout,
      GraphViewGeometry? geometry});

  $GraphIdCopyWith<$Res> get id;
  $GraphViewGeometryCopyWith<$Res>? get geometry;
}

/// @nodoc
class _$GraphDataCopyWithImpl<$Res, $Val extends GraphData>
    implements $GraphDataCopyWith<$Res> {
  _$GraphDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GraphData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? nodes = null,
    Object? links = null,
    Object? selectedNodeIds = null,
    Object? selectedLinkIds = null,
    Object? allowSelection = null,
    Object? allowMultiSelection = null,
    Object? needsLayout = null,
    Object? geometry = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as GraphId,
      nodes: null == nodes
          ? _value.nodes
          : nodes // ignore: cast_nullable_to_non_nullable
              as IMap<GraphId, GraphNode>,
      links: null == links
          ? _value.links
          : links // ignore: cast_nullable_to_non_nullable
              as IMap<GraphId, GraphLink>,
      selectedNodeIds: null == selectedNodeIds
          ? _value.selectedNodeIds
          : selectedNodeIds // ignore: cast_nullable_to_non_nullable
              as IList<GraphId>,
      selectedLinkIds: null == selectedLinkIds
          ? _value.selectedLinkIds
          : selectedLinkIds // ignore: cast_nullable_to_non_nullable
              as IList<GraphId>,
      allowSelection: null == allowSelection
          ? _value.allowSelection
          : allowSelection // ignore: cast_nullable_to_non_nullable
              as bool,
      allowMultiSelection: null == allowMultiSelection
          ? _value.allowMultiSelection
          : allowMultiSelection // ignore: cast_nullable_to_non_nullable
              as bool,
      needsLayout: null == needsLayout
          ? _value.needsLayout
          : needsLayout // ignore: cast_nullable_to_non_nullable
              as bool,
      geometry: freezed == geometry
          ? _value.geometry
          : geometry // ignore: cast_nullable_to_non_nullable
              as GraphViewGeometry?,
    ) as $Val);
  }

  /// Create a copy of GraphData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GraphIdCopyWith<$Res> get id {
    return $GraphIdCopyWith<$Res>(_value.id, (value) {
      return _then(_value.copyWith(id: value) as $Val);
    });
  }

  /// Create a copy of GraphData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GraphViewGeometryCopyWith<$Res>? get geometry {
    if (_value.geometry == null) {
      return null;
    }

    return $GraphViewGeometryCopyWith<$Res>(_value.geometry!, (value) {
      return _then(_value.copyWith(geometry: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$GraphDataImplCopyWith<$Res>
    implements $GraphDataCopyWith<$Res> {
  factory _$$GraphDataImplCopyWith(
          _$GraphDataImpl value, $Res Function(_$GraphDataImpl) then) =
      __$$GraphDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {GraphId id,
      IMap<GraphId, GraphNode> nodes,
      IMap<GraphId, GraphLink> links,
      IList<GraphId> selectedNodeIds,
      IList<GraphId> selectedLinkIds,
      bool allowSelection,
      bool allowMultiSelection,
      bool needsLayout,
      GraphViewGeometry? geometry});

  @override
  $GraphIdCopyWith<$Res> get id;
  @override
  $GraphViewGeometryCopyWith<$Res>? get geometry;
}

/// @nodoc
class __$$GraphDataImplCopyWithImpl<$Res>
    extends _$GraphDataCopyWithImpl<$Res, _$GraphDataImpl>
    implements _$$GraphDataImplCopyWith<$Res> {
  __$$GraphDataImplCopyWithImpl(
      _$GraphDataImpl _value, $Res Function(_$GraphDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of GraphData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? nodes = null,
    Object? links = null,
    Object? selectedNodeIds = null,
    Object? selectedLinkIds = null,
    Object? allowSelection = null,
    Object? allowMultiSelection = null,
    Object? needsLayout = null,
    Object? geometry = freezed,
  }) {
    return _then(_$GraphDataImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as GraphId,
      nodes: null == nodes
          ? _value.nodes
          : nodes // ignore: cast_nullable_to_non_nullable
              as IMap<GraphId, GraphNode>,
      links: null == links
          ? _value.links
          : links // ignore: cast_nullable_to_non_nullable
              as IMap<GraphId, GraphLink>,
      selectedNodeIds: null == selectedNodeIds
          ? _value.selectedNodeIds
          : selectedNodeIds // ignore: cast_nullable_to_non_nullable
              as IList<GraphId>,
      selectedLinkIds: null == selectedLinkIds
          ? _value.selectedLinkIds
          : selectedLinkIds // ignore: cast_nullable_to_non_nullable
              as IList<GraphId>,
      allowSelection: null == allowSelection
          ? _value.allowSelection
          : allowSelection // ignore: cast_nullable_to_non_nullable
              as bool,
      allowMultiSelection: null == allowMultiSelection
          ? _value.allowMultiSelection
          : allowMultiSelection // ignore: cast_nullable_to_non_nullable
              as bool,
      needsLayout: null == needsLayout
          ? _value.needsLayout
          : needsLayout // ignore: cast_nullable_to_non_nullable
              as bool,
      geometry: freezed == geometry
          ? _value.geometry
          : geometry // ignore: cast_nullable_to_non_nullable
              as GraphViewGeometry?,
    ));
  }
}

/// @nodoc

class _$GraphDataImpl implements _GraphData {
  const _$GraphDataImpl(
      {required this.id,
      this.nodes = const IMapConst({}),
      this.links = const IMapConst({}),
      this.selectedNodeIds = const IListConst([]),
      this.selectedLinkIds = const IListConst([]),
      this.allowSelection = true,
      this.allowMultiSelection = false,
      this.needsLayout = true,
      this.geometry});

  /// Unique identifier for this graph instance.
  @override
  final GraphId id;

  /// Map of node IDs to their corresponding [GraphNode] instances.
  @override
  @JsonKey()
  final IMap<GraphId, GraphNode> nodes;

  /// Map of link IDs to their corresponding [GraphLink] instances.
  @override
  @JsonKey()
  final IMap<GraphId, GraphLink> links;

  /// List of IDs for currently selected nodes.
  @override
  @JsonKey()
  final IList<GraphId> selectedNodeIds;

  /// List of IDs for currently selected links.
  @override
  @JsonKey()
  final IList<GraphId> selectedLinkIds;

  /// Whether selection of graph elements is enabled.
  @override
  @JsonKey()
  final bool allowSelection;

  /// Whether multiple elements can be selected simultaneously.
  @override
  @JsonKey()
  final bool allowMultiSelection;
  @override
  @JsonKey()
  final bool needsLayout;
  @override
  final GraphViewGeometry? geometry;

  @override
  String toString() {
    return 'GraphData(id: $id, nodes: $nodes, links: $links, selectedNodeIds: $selectedNodeIds, selectedLinkIds: $selectedLinkIds, allowSelection: $allowSelection, allowMultiSelection: $allowMultiSelection, needsLayout: $needsLayout, geometry: $geometry)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GraphDataImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.nodes, nodes) || other.nodes == nodes) &&
            (identical(other.links, links) || other.links == links) &&
            const DeepCollectionEquality()
                .equals(other.selectedNodeIds, selectedNodeIds) &&
            const DeepCollectionEquality()
                .equals(other.selectedLinkIds, selectedLinkIds) &&
            (identical(other.allowSelection, allowSelection) ||
                other.allowSelection == allowSelection) &&
            (identical(other.allowMultiSelection, allowMultiSelection) ||
                other.allowMultiSelection == allowMultiSelection) &&
            (identical(other.needsLayout, needsLayout) ||
                other.needsLayout == needsLayout) &&
            (identical(other.geometry, geometry) ||
                other.geometry == geometry));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      nodes,
      links,
      const DeepCollectionEquality().hash(selectedNodeIds),
      const DeepCollectionEquality().hash(selectedLinkIds),
      allowSelection,
      allowMultiSelection,
      needsLayout,
      geometry);

  /// Create a copy of GraphData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GraphDataImplCopyWith<_$GraphDataImpl> get copyWith =>
      __$$GraphDataImplCopyWithImpl<_$GraphDataImpl>(this, _$identity);
}

abstract class _GraphData implements GraphData {
  const factory _GraphData(
      {required final GraphId id,
      final IMap<GraphId, GraphNode> nodes,
      final IMap<GraphId, GraphLink> links,
      final IList<GraphId> selectedNodeIds,
      final IList<GraphId> selectedLinkIds,
      final bool allowSelection,
      final bool allowMultiSelection,
      final bool needsLayout,
      final GraphViewGeometry? geometry}) = _$GraphDataImpl;

  /// Unique identifier for this graph instance.
  @override
  GraphId get id;

  /// Map of node IDs to their corresponding [GraphNode] instances.
  @override
  IMap<GraphId, GraphNode> get nodes;

  /// Map of link IDs to their corresponding [GraphLink] instances.
  @override
  IMap<GraphId, GraphLink> get links;

  /// List of IDs for currently selected nodes.
  @override
  IList<GraphId> get selectedNodeIds;

  /// List of IDs for currently selected links.
  @override
  IList<GraphId> get selectedLinkIds;

  /// Whether selection of graph elements is enabled.
  @override
  bool get allowSelection;

  /// Whether multiple elements can be selected simultaneously.
  @override
  bool get allowMultiSelection;
  @override
  bool get needsLayout;
  @override
  GraphViewGeometry? get geometry;

  /// Create a copy of GraphData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GraphDataImplCopyWith<_$GraphDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
